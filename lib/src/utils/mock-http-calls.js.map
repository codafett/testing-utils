{"version":3,"file":"mock-http-calls.js","sourceRoot":"","sources":["../../../src/utils/mock-http-calls.ts"],"names":[],"mappings":";;;;;;AAAA,gDAMc;AAEd,qCAAqC;AACrC,IAAY,gBAOX;AAPD,WAAY,gBAAgB;IAC1B,iCAAa,CAAA;IACb,+BAAW,CAAA;IACX,iCAAa,CAAA;IACb,+BAAW,CAAA;IACX,mCAAe,CAAA;IACf,qCAAiB,CAAA;AACnB,CAAC,EAPW,gBAAgB,GAAhB,wBAAgB,KAAhB,wBAAgB,QAO3B;AAYD,MAAM,SAAS,GACb;IACE,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC,KAAY,EAAE,EAAE,CAAC,KAAK,CAAC,IAAI;IACrD,CAAC,gBAAgB,CAAC,GAAG,CAAC,EAAE,CAAC,KAAY,EAAE,EAAE,CAAC,KAAK,CAAC,GAAG;IACnD,CAAC,gBAAgB,CAAC,IAAI,CAAC,EAAE,CAAC,KAAY,EAAE,EAAE,CAAC,KAAK,CAAC,IAAI;IACrD,CAAC,gBAAgB,CAAC,GAAG,CAAC,EAAE,CAAC,KAAY,EAAE,EAAE,CAAC,KAAK,CAAC,GAAG;IACnD,CAAC,gBAAgB,CAAC,KAAK,CAAC,EAAE,CAAC,KAAY,EAAE,EAAE,CAAC,KAAK,CAAC,KAAK;IACvD,CAAC,gBAAgB,CAAC,MAAM,CAAC,EAAE,CAAC,KAAY,EAAE,EAAE,CAAC,KAAK,CAAC,MAAM;CAC1D,CAAC;AAOJ,SAAgB,aAAa,CAC3B,QAAgB,EAChB,mBAAyC,EACzC,UAA2B,EAAE,OAAO,EAAE,KAAK,EAAE;IAE7C,MAAM,KAAK,GAAG,IAAA,cAAI,EAAC,QAAQ,EAAE;QAC3B,aAAa,EAAE,OAAO,EAAE,qBAAqB,IAAI,KAAK;KACvD,CAAC,CAAC;IACH,mBAAmB,CAAC,OAAO,CAAC,CAAC,kBAAkB,EAAE,EAAE;QACjD,MAAM,eAAe,GAAgB,SAAS,CAC5C,kBAAkB,CAAC,IAAI,CACxB,CAAC,KAAK,CAAC,CAAC,IAAI,CACX,KAAK,EACL,kBAAkB,CAAC,GAAG,EACtB,kBAAkB,CAAC,WAAW,EAC9B,kBAAkB,CAAC,kBAAkB,CACtC,CAAC;QACF,eAAe;aACZ,KAAK,CAAC,kBAAkB,CAAC,MAAM,IAAI,GAAG,EAAE;YACvC,IAAI,EAAE,kBAAkB,CAAC,YAAY;SACtC,CAAC;aACD,OAAO,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC;IACzC,CAAC,CAAC,CAAC;IACH,IAAI,OAAO,CAAC,OAAO,EAAE;QACnB,KAAK,CAAC,OAAO,EAAE,CAAC;KACjB;IACD,OAAO,KAAK,CAAC;AACf,CAAC;AA3BD,sCA2BC;AAED,SAAgB,qBAAqB;IACnC,cAAI,CAAC,QAAQ,EAAE,CAAC;AAClB,CAAC;AAFD,sDAEC;AAED,SAAgB,cAAc,CAAC,OAA+B;IAC5D,cAAI,CAAC,OAAO,CAAC,EAAE,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;AACvC,CAAC;AAFD,wCAEC","sourcesContent":["import nock, {\n  InterceptFunction,\n  Interceptor,\n  Options,\n  RequestBodyMatcher,\n  Scope,\n} from 'nock';\n\n// eslint-disable-next-line no-shadow\nexport enum MockHttpCallType {\n  HEAD = 'head',\n  GET = 'get',\n  POST = 'post',\n  PUT = 'put',\n  PATCH = 'patch',\n  DELETE = 'delete',\n}\n\nexport interface HttpCallDefinition {\n  url: string;\n  type: MockHttpCallType;\n  requestBody?: RequestBodyMatcher;\n  responseData?: unknown;\n  interceptorOptions?: Options;\n  status?: number;\n  persist?: boolean;\n}\n\nconst httpCalls: Record<string, (scope: Scope) => InterceptFunction> =\n  {\n    [MockHttpCallType.HEAD]: (scope: Scope) => scope.head,\n    [MockHttpCallType.GET]: (scope: Scope) => scope.get,\n    [MockHttpCallType.POST]: (scope: Scope) => scope.post,\n    [MockHttpCallType.PUT]: (scope: Scope) => scope.put,\n    [MockHttpCallType.PATCH]: (scope: Scope) => scope.patch,\n    [MockHttpCallType.DELETE]: (scope: Scope) => scope.delete,\n  };\n\nexport interface HttpMockOptions {\n  allowUnmockedRequests?: boolean;\n  persist?: boolean;\n}\n\nexport function mockHttpCalls(\n  basePath: string,\n  httpCallDefinitions: HttpCallDefinition[],\n  options: HttpMockOptions = { persist: false },\n) {\n  const scope = nock(basePath, {\n    allowUnmocked: options?.allowUnmockedRequests || false,\n  });\n  httpCallDefinitions.forEach((httpCallDefinition) => {\n    const httpInterceptor: Interceptor = httpCalls[\n      httpCallDefinition.type\n    ](scope).call(\n      scope,\n      httpCallDefinition.url,\n      httpCallDefinition.requestBody,\n      httpCallDefinition.interceptorOptions,\n    );\n    httpInterceptor\n      .reply(httpCallDefinition.status || 200, {\n        data: httpCallDefinition.responseData,\n      })\n      .persist(httpCallDefinition.persist);\n  });\n  if (options.persist) {\n    scope.persist();\n  }\n  return scope;\n}\n\nexport function cleanAllMockHttpCalls() {\n  nock.cleanAll();\n}\n\nexport function onUnmockedCall(handler: (req: unknown) => void) {\n  nock.emitter.on('no match', handler);\n}\n"]}